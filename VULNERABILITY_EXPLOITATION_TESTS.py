#!/usr/bin/env python3
"""
üö® CRITICAL VULNERABILITY EXPLOITATION TESTS
Demonstrates actual exploits for identified security issues
DO NOT RUN IN PRODUCTION - FOR SECURITY TESTING ONLY
"""

import sys
import time
import threading
import numpy as np
from datetime import datetime, timezone
import gc
import psutil
import os

sys.path.insert(0, 'src')

def test_datetime_vulnerability():
    """Test timezone-naive datetime vulnerability"""
    print("\nüî¥ TESTING: Datetime Timezone Vulnerability")
    
    from kimera.identity import Identity
    
    # Create identity with timezone-naive timestamp
    identity = Identity(content="test")
    
    # Demonstrate the vulnerability
    print(f"Created timestamp: {identity.created_at}")
    print(f"Timezone info: {identity.created_at.tzinfo}")
    print(f"‚ö†Ô∏è  VULNERABILITY: Timestamp is timezone-naive!")
    
    # Simulate timezone confusion attack
    import os
    original_tz = os.environ.get('TZ', '')
    
    try:
        # Change timezone during processing
        os.environ['TZ'] = 'US/Pacific'
        time.tzset()
        identity2 = Identity(content="test2")
        
        os.environ['TZ'] = 'UTC'
        time.tzset()
        identity3 = Identity(content="test3")
        
        print(f"Identity 2 timestamp: {identity2.created_at}")
        print(f"Identity 3 timestamp: {identity3.created_at}")
        print("üö® EXPLOIT: Timestamps may be ambiguous across timezones!")
        
    finally:
        os.environ['TZ'] = original_tz
        time.tzset()
    
    return True

def test_numpy_injection_vulnerability():
    """Test numpy array injection vulnerability"""
    print("\nüî¥ TESTING: Numpy Array Injection Vulnerability")
    
    from kimera.identity import Identity
    
    # Test 1: Memory exhaustion attack
    try:
        # Create massive array (this could crash the system)
        print("Creating large array (10MB)...")
        large_array = np.ones((1000, 1000), dtype=np.float64)  # 8MB
        
        identity = Identity(
            content="malicious",
            vector=large_array
        )
        
        print(f"‚ö†Ô∏è  Array size: {large_array.nbytes / 1024 / 1024:.1f} MB")
        print("üö® VULNERABILITY: No size limits on numpy arrays!")
        
    except MemoryError:
        print("üí• EXPLOIT SUCCESSFUL: Memory exhaustion!")
        return True
    
    # Test 2: Type confusion attack
    try:
        # Create array with unexpected dtype
        malicious_array = np.array([1, 2, 3], dtype=np.object_)
        malicious_array[0] = lambda x: x  # Function object
        
        identity = Identity(
            content="type_confusion",
            vector=malicious_array
        )
        
        print("üö® VULNERABILITY: Object arrays can contain arbitrary Python objects!")
        
    except Exception as e:
        print(f"Partial exploit: {e}")
    
    return True

def test_recursion_vulnerability():
    """Test unbounded recursion vulnerability"""
    print("\nüî¥ TESTING: Unbounded Recursion Vulnerability")
    
    from kimera.echoform import EchoForm
    
    # Create recursive EchoForm
    echo = EchoForm(config={"recursive": True})
    
    # Simulate deep recursion (this could cause stack overflow)
    def recursive_processing(depth=0):
        if depth > 1000:  # Limit for testing
            return "max_depth_reached"
        
        # Simulate recursive form processing
        new_echo = EchoForm(config={"recursive": True})
        return recursive_processing(depth + 1)
    
    try:
        result = recursive_processing()
        print(f"Recursion test result: {result}")
        print("üö® VULNERABILITY: No recursion depth limits!")
        
    except RecursionError:
        print("üí• EXPLOIT SUCCESSFUL: Stack overflow!")
        return True
    
    return True

def test_entropy_overflow_vulnerability():
    """Test entropy calculation overflow vulnerability"""
    print("\nüî¥ TESTING: Entropy Calculation Overflow Vulnerability")
    
    from kimera.echoform import EchoForm
    import math
    
    echo = EchoForm()
    
    # Test 1: Infinity injection
    try:
        echo.add_term("infinity_bomb", intensity=float('inf'))
        entropy = echo.entropy()
        print(f"Entropy with infinity: {entropy}")
        
        if math.isnan(entropy) or math.isinf(entropy):
            print("üí• EXPLOIT SUCCESSFUL: NaN/Infinity propagation!")
        else:
            print("üö® VULNERABILITY: Infinity not properly handled!")
            
    except Exception as e:
        print(f"Exception with infinity: {e}")
    
    # Test 2: Very large numbers
    try:
        echo.add_term("large_bomb", intensity=1e308)  # Near float64 limit
        entropy = echo.entropy()
        print(f"Entropy with large number: {entropy}")
        
    except OverflowError:
        print("üí• EXPLOIT SUCCESSFUL: Overflow error!")
        return True
    
    # Test 3: Very small numbers (underflow)
    try:
        echo.add_term("small_bomb", intensity=1e-324)  # Near float64 limit
        entropy = echo.entropy()
        print(f"Entropy with tiny number: {entropy}")
        
    except Exception as e:
        print(f"Exception with tiny number: {e}")
    
    return True

def test_metadata_injection_vulnerability():
    """Test metadata injection vulnerability"""
    print("\nüî¥ TESTING: Metadata Injection Vulnerability")
    
    from kimera.identity import Identity
    
    identity = Identity(content="victim")
    
    # Test 1: Memory exhaustion via large metadata
    try:
        print("Injecting large metadata values...")
        for i in range(100):  # Reduced for testing
            large_value = "X" * 10000  # 10KB per entry
            identity.update_metadata(f"attack_key_{i}", large_value)
        
        print(f"Metadata keys: {len(identity.meta)}")
        total_size = sum(len(str(v)) for v in identity.meta.values())
        print(f"Total metadata size: {total_size / 1024:.1f} KB")
        print("üö® VULNERABILITY: No size limits on metadata!")
        
    except MemoryError:
        print("üí• EXPLOIT SUCCESSFUL: Memory exhaustion!")
        return True
    
    # Test 2: Key collision attack
    try:
        # Try to overwrite system keys
        identity.update_metadata("__class__", "malicious")
        identity.update_metadata("__dict__", {"evil": True})
        
        print("üö® VULNERABILITY: No key validation - system keys can be overwritten!")
        
    except Exception as e:
        print(f"Key collision prevented: {e}")
    
    # Test 3: Type confusion attack
    try:
        # Inject complex objects
        identity.update_metadata("function", lambda x: x)
        identity.update_metadata("class", type)
        identity.update_metadata("module", sys)
        
        print("üö® VULNERABILITY: No type validation - arbitrary objects can be stored!")
        
    except Exception as e:
        print(f"Type injection prevented: {e}")
    
    return True

def test_race_condition_vulnerability():
    """Test race condition vulnerability"""
    print("\nüî¥ TESTING: Race Condition Vulnerability")
    
    from kimera.identity import Identity
    
    identity = Identity(content="shared")
    results = []
    
    def concurrent_update(thread_id):
        """Simulate concurrent metadata updates"""
        for i in range(100):
            identity.update_metadata(f"thread_{thread_id}_key_{i}", f"value_{i}")
            # Simulate some processing time
            time.sleep(0.001)
        results.append(f"Thread {thread_id} completed")
    
    # Start multiple threads
    threads = []
    for i in range(5):
        thread = threading.Thread(target=concurrent_update, args=(i,))
        threads.append(thread)
        thread.start()
    
    # Wait for completion
    for thread in threads:
        thread.join()
    
    print(f"Concurrent updates completed: {len(results)}")
    print(f"Final metadata keys: {len(identity.meta)}")
    print("üö® VULNERABILITY: No thread safety - race conditions possible!")
    
    return True

def test_memory_exhaustion_attack():
    """Test comprehensive memory exhaustion attack"""
    print("\nüî¥ TESTING: Memory Exhaustion Attack")
    
    from kimera.echoform import EchoForm
    from kimera.identity import Identity
    
    # Get initial memory usage
    process = psutil.Process(os.getpid())
    initial_memory = process.memory_info().rss / 1024 / 1024  # MB
    
    print(f"Initial memory usage: {initial_memory:.1f} MB")
    
    # Attack 1: Create many EchoForms with large term dictionaries
    echoforms = []
    try:
        for i in range(100):  # Reduced for testing
            echo = EchoForm(anchor=f"attack_{i}")
            
            # Add many terms
            for j in range(100):  # 10,000 terms total
                echo.add_term(f"term_{i}_{j}", intensity=1.0)
            
            echoforms.append(echo)
            
            if i % 10 == 0:
                current_memory = process.memory_info().rss / 1024 / 1024
                print(f"Memory after {i+1} forms: {current_memory:.1f} MB (+{current_memory-initial_memory:.1f})")
        
        final_memory = process.memory_info().rss / 1024 / 1024
        print(f"Final memory usage: {final_memory:.1f} MB")
        print(f"Memory increase: {final_memory - initial_memory:.1f} MB")
        print("üö® VULNERABILITY: No memory limits - unbounded growth possible!")
        
    except MemoryError:
        print("üí• EXPLOIT SUCCESSFUL: Memory exhaustion!")
        return True
    finally:
        # Cleanup
        del echoforms
        gc.collect()
    
    return True

def test_serialization_vulnerability():
    """Test serialization vulnerabilities"""
    print("\nüî¥ TESTING: Serialization Vulnerability")
    
    from kimera.identity import Identity
    from kimera.echoform import EchoForm
    
    # Test 1: Circular reference
    identity1 = Identity(content="ref1")
    identity2 = Identity(content="ref2")
    
    # Create circular reference in metadata
    identity1.update_metadata("ref", identity2)
    identity2.update_metadata("ref", identity1)
    
    try:
        # This could cause infinite recursion during serialization
        data1 = identity1.to_dict()
        print("üö® VULNERABILITY: Circular references not handled in serialization!")
        
    except RecursionError:
        print("üí• EXPLOIT SUCCESSFUL: Infinite recursion in serialization!")
        return True
    except Exception as e:
        print(f"Serialization error: {e}")
    
    # Test 2: Deep object nesting
    echo = EchoForm()
    
    # Create deeply nested structure
    nested = {"level": 0}
    current = nested
    for i in range(100):  # Deep nesting
        current["next"] = {"level": i+1}
        current = current["next"]
    
    echo.add_term("nested_bomb", intensity=1.0, metadata=nested)
    
    try:
        data = echo.to_dict()
        print("üö® VULNERABILITY: Deep nesting not limited in serialization!")
        
    except RecursionError:
        print("üí• EXPLOIT SUCCESSFUL: Deep nesting causes recursion error!")
        return True
    
    return True

def run_all_vulnerability_tests():
    """Run all vulnerability tests"""
    print("üö® KIMERA-SWM VULNERABILITY EXPLOITATION TESTS")
    print("=" * 60)
    print("‚ö†Ô∏è  WARNING: These tests demonstrate actual security vulnerabilities!")
    print("‚ö†Ô∏è  DO NOT RUN IN PRODUCTION ENVIRONMENTS!")
    print("=" * 60)
    
    tests = [
        ("Datetime Timezone Vulnerability", test_datetime_vulnerability),
        ("Numpy Array Injection", test_numpy_injection_vulnerability),
        ("Unbounded Recursion", test_recursion_vulnerability),
        ("Entropy Overflow", test_entropy_overflow_vulnerability),
        ("Metadata Injection", test_metadata_injection_vulnerability),
        ("Race Conditions", test_race_condition_vulnerability),
        ("Memory Exhaustion", test_memory_exhaustion_attack),
        ("Serialization Vulnerabilities", test_serialization_vulnerability),
    ]
    
    passed = 0
    total = len(tests)
    
    for test_name, test_func in tests:
        try:
            print(f"\n{'='*60}")
            print(f"üß™ RUNNING: {test_name}")
            print(f"{'='*60}")
            
            result = test_func()
            if result:
                passed += 1
                print(f"‚úÖ {test_name}: VULNERABILITY CONFIRMED")
            else:
                print(f"‚ùå {test_name}: Test failed")
                
        except Exception as e:
            print(f"üí• {test_name}: CRITICAL ERROR - {e}")
            passed += 1  # Error indicates vulnerability
    
    print(f"\n{'='*60}")
    print(f"üö® VULNERABILITY TEST RESULTS")
    print(f"{'='*60}")
    print(f"Vulnerabilities confirmed: {passed}/{total}")
    print(f"Security status: {'üî¥ CRITICAL - UNSAFE FOR PRODUCTION' if passed > 0 else 'üü¢ SECURE'}")
    
    if passed > 0:
        print(f"\n‚ö†Ô∏è  IMMEDIATE ACTION REQUIRED:")
        print(f"   - Fix all identified vulnerabilities")
        print(f"   - Implement security hardening measures")
        print(f"   - Conduct penetration testing")
        print(f"   - Review code with security experts")
        print(f"   - DO NOT DEPLOY TO PRODUCTION")
    
    return passed == 0

if __name__ == "__main__":
    import warnings
    warnings.filterwarnings("ignore")  # Suppress warnings for cleaner output
    
    print("üö® STARTING VULNERABILITY EXPLOITATION TESTS...")
    print("‚ö†Ô∏è  These tests may consume significant system resources!")
    
    try:
        secure = run_all_vulnerability_tests()
        sys.exit(0 if secure else 1)
    except KeyboardInterrupt:
        print("\n\nüõë Tests interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n\nüí• CRITICAL ERROR DURING TESTING: {e}")
        sys.exit(1)